
## 簡易的快速整理方法
- 守衛語句(波動拳) => 攤平更好讀
- Dead Code => 可以刪除減少干擾 (反正都在 git 裡)
- 用同樣的語法做一樣的事 => 統一程式碼風格
- 用新的介面實作舊的方法 => legacy code 包起來用
- 閱讀順序 => 貼合思考順序
- 內聚順序 => 先改程式碼的順序，在調整耦合的地方
- 把宣告變數和初始化 or 使用的地方盡可能靠近
- 具有解釋性的變數 or 常數 => no magic number
- 明確的參數
- 把程式碼切塊, 提取輔助函式 => 通常有分塊都可以抽方法來表示目的
- 匯聚成一堆 => 有時候被拆太多小片段難以一次理解 就先整合再一起之後再處理
- 加有解釋效果的註解
- 刪除多餘的註解 => 程式碼意圖購明顯就不用註解

## 整理 code 的時機
- 完全不整理
    - 永遠不會再改那段 code
    - 改善了也不會有收穫
- 晚點再去整理
    - 有很多要整理，但不會馬上有回報
    - 完成整理，最後還是有回報
    - 可以一小批一小批整理
- 改變之後立刻整理
    - 下次做整理成本會變高
    - 改了沒整理會有事情沒做完的感覺
- 改變前先整理
    - 馬上有回報，增強理解 or 降低改的成本
    - 很清楚要改啥 or 怎麼改

---

## 用選擇權&現金流比喻

- 現金流 => 賺錢優先
    - 先改動，之後有機會再整理
- 選擇權 => 先花點錢，以後能有更大的利潤
    - 先整理再改動再整理
- 成本 ( 整理 ) + 成本 ( 整理後在去作行為上的改變 ) < 成本 ( 不整理就改動 )

---

- 軟體發布後的成本 ~= 大改變的成本 ~= 耦合程度
- 軟體複雜度守恆 => 解偶是要讓程式碼有更多改變的選擇
- 終極目標 => 高內聚低耦合

- 整理所需考量的事項
    - 成本 => 整理能否讓成本變少 or 延後付出
    - 收益 => 能否增加收益 or 更快取得收益
    - 耦合 => 整理完是否能讓改動更少
    - 內聚 => 整理完改動的範圍能否更少
